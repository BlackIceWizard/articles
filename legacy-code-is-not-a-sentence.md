# Легаси код - не приговор.

Доброго времени суток! Сегодня я хочу поговорить о том, как относиться к легаси коду в вашем проекте, возможно ли повысить качество кода проекта, в котором есть подобное сомнительное наследство или даже избавить проект от него полностью.

Разберемся в том, что такое легаси код и откуда он берется. Если охарактеризовать понятие легаси код максимально кратко, то это будет аналогия с "чемоданом без ручки". Нести тяжело, но и бросить нельзя. Легаси код - код, который в силу стечения каких-либо обстоятельств стал тяжело поддерживаемым. Обычно это часть проекта или проект целиком, доставшиеся от других разработчиков. Либо разработчики остались те же, что и писали легаси код, но прошло много времени и никто уже не помнит и как зачем этот код писался именно так, да еще и стандарты разработки уже давно сменились, но наследство никто не трогал по принципу "работает - не трогай". Как бы то ни было, мы имеем в итоге код, который не соответствует текущим принятым в команде требованиям. А любая попытка внести новый функционал или исправить старые баги приводит лишь к дальнейшему ухудшению чистоты кода вплоть до полной невозможности дальнейшей поддержки.

За свою карьеру я встречал программистов двух типов. Первые однозначно воспринимали проекты с легаси кодом как нечто необратимо испорченное - яму, в которую можно бесконечно лить человеко-часы. Процитирую дословно слова одного из них: - "До меня тут другие люди ж работали). Так что говна хватает. Ну я тоже не стесняюсь. Своего говна тоже лопатами накидываю". Вторые же... Процитирую дословно слова одного из них: - "Я еще и не из такого дерьма делал конфетку". Для первых легаси код - приговор. Для вторых, судя по всему - нет.

Первой реакцией программистов, которую приходится наблюдать при известии о том, что они будут работать с проектом, в котором есть легасикод, оказывается "Давайте лучше его полностью перепишем". Этот вариант решения мы рассматривать не будем сразу по нескольким причинам. Первая - мне нечего будет вам рассказать, потому что это разработка с нуля - просто делайте все в лучшем виде, если вам так повезло. Вторая причина - очень мало шансов, что в конкретно взятом случае бизнес выделит достаточно времени на переписывание всего с нуля. У меня за 17 лет работы программистом такое было лишь однажды. И то лишь потому, что проект был небольшим.

Однако, если не иметь возможности переписать все в лучшем виде, программисты лишаются вроде бы как единственной возможности улучшить поддержвиваемость проекта, что приведет его к гибели. Что не редкость, между прочим. Идея остановить производство нового функционала и полностью погрузиться в рефакторинг - тоже не выход, о чем я ниже упомяну - легаси код почти никогда не соответствует актуальным требованиям бизнеса к проекту. И такая работа будет проведена впустую, ведь будет создан проект хоть и с чистым кодом, но при этом лишь частично отвечающий требованиям бизнеса. Жуткая растрата ресурсов, скажем прямо.

Цель заводить интригу я себе не ставил, так что сразу переходим к тому, как выходить из сложившейся ситуации. Идея, в действительности не нова и достаточно проста. А именно - повысить модульность проекта и переписывать его постепенно, доводя до принятых в команде требований. Но тут есть свои правила, которым нужно следовать, чтобы замысел удался.

Разберемся на примере. Допустим мы разрабатываем интернет-магазин, в нем есть сущность продукта. Допустим так же, что у нас каноничный спагетти код, в котором атрибуты, тоже являющиеся сущностями, так хаотично пересекаются в логике с функционалом работы со складом, что отделить одно от другого уже не целесообразно по времязатратам. И где-то сбоку уже устаревший даже по меркам легаси кода функционал скидок. И вот перед вами бизнес ставит задачу воскресить этот функционал скидок.

Что предпринимают разработчики не успевшие обжечься на подобном? Они идут воскрешать уже написанный функционал в буквальном смысле. Возможно, программисту хватит изобретательности, чтобы не только оживить старую логику, но и отрефакторить ее путем заметания нечистот по углам и под ковры. Работа по уменьшению связанности в приложении проведена, дублирующий код почищен, четко выстроены уровни абстракции...  Но все это что мертвому припарки. Хоть и выглядит чисто и опрятно. Такие улучшения в действительности не решают задачи бизнеса. В действительности, если называть вещи своими словами, то разработчик воскресил старую концепцию скидок и заставили мириться бизнес с тем, что ему придется спустя несколько лет пользоваться старой схемой скидок, пытаясь втиснуть ее в новые условия рынка. Да к тому же не смотря на всю работу по снижению уровня связанности функционал скидок будет все равно работать с товарами именно по схеме, предусмотренной в функционале товаров. Кроме всего прочего можно выделить еще и излишнюю трату времени на попытку понять, как работал раньше функционал скидок и на сложный рефакторинг, а так же то что функционал скидок почти со 100 процентной вероятности получится сложным, пытаясь угодить чувству прекрасного программиста и при этом работать внутри легаси кода.

Чтобы понять ошибку программиста по отношению к бизнесу при попытке реанимировать старый код, нужно понимать, что очень редкий вид бизнеса стоит на месте. Agile как раз и стал так популярен из-за того, что команда разработчиков в любой момент готова принять новое видение, концепцию продукта. Бизнес постоянно меняется, переосмысливает сам себя либо погибает. Это закон нашей с вами современности. Выходит, что программист, если по уму, должен был собрать требования от бизнеса к механизму скидок. И далее поступить как я раньше и предложил повысить модульность проекта. А именно создать новый модуль, который лаконично будет в себе кристаллизовать лишь то, что касается скидок и самых актуальных требований от бизнеса. В зависимости от фреймворка и языка программирования под модулем могу подразумеваться библиотеки, бандлы, компоненты и прочее, и прочее. Главное - в этом модуле полностью абстрагироваться от остального проекта. SRP уровня архитектуры, скажем так. Этот модуль должен быть без всяких оговорок выполнен именно на том уровне качестве кода, на который способна команда разработчиков - все лучшие практики применимые к модулю должны быть к нему применены. На выходе вы должны получить самый лучший модуль, реализующий актуальные требования бизнеса к скидкам, который вы только можете представить.

Но вы спросите... А что же с легаси кодом? Легаси продукт ведь не сможет взаимодействовать с новым модулем. Что если легаси вообще может быть написан на другой версии фреймворка или даже версии языка программирования? Да... И что делать с тем куском кода, который раньше отвечал за скидки?

И так. Что делать со старым кодом, который вы переписали в лучшем виде - если можно сделать в краткие сроки, то удалить. Зачем он нужен? Однако, если это проблематично, например, как и полагается в спагетти проекте, он используется в других местах, то вы помечаете старый код тегом deprecated. Устарело - по-русски. Всякий, кто будет вынужден залезть в легасикод в целях внести маленькие правки, то увидит, что вы предписали использовать новый функционал и это будет помогать в том, чтобы не переиспользовать не актуальный код. Рано или поздно окажется, что старые скидки нигде больше не используются в проекте и их можно будет безболезненно удалить.

И да, легаси продукт не будет соответствовать вашему новому модулю. Вам придется делать адаптер или несколько адаптеров. Местами вам придется делать точечные изменения в продукте. Не бойтесь при этом получить дублирование кода. Будьте безжалостны. Для примера, допустим, что в новых модулях вы используете не порядковый номер как идентификатор продукта, а immutable ValueObject, хранящий артикул продукта. Добавить метод в сущность продукта, которые позволят получить этот ValueObject, а порядковый номер пометьте как устаревший. Когда не останется мест, где используется старый идентификатор - вы его удалите и сделаете первичным ключом артикул. Если вы работаете по DDD, то окажется, что вам нужно многие классы, что находятся в легаси коде, иметь в соответствующих директориях, пространствах имен или пакетах проекта. Имею в виду привычные вам Domain, Infrastructure и Application. Вы можете создать эти директории в легаси коде и разместить в них интерфейсы продукта и склада. Дописать соответствующие классы в легаси коде, чтобы они реализовывали эти интерфейсы и получать их как зависимости уже по интерфейсам. Что я хочу сказать - не должно быть оправданий, что легаси код не позволил написать новый модуль в лучшем виде, что вы затянули в новый модуль старую логику, чтобы она работала с легаси кодом. Нет! Вы должны внести достаточно точечных изменений в легаси код, который, возможно его сделают даже монструознее, но взамен вы получаете новый модуль, который можно назвать без всяких компромиссов современным. Повторюсь, так как это главное в этом процессе: если вы хотите омолодить проект, то любой новый написанный вами модуль должен быть бескомпромиссно выполнен по самым новым стандартам. Это правило нужно соблюдать даже в тех проектах, где нет легаси и где нет старого кода, но есть новый и новейший код.

Что делать, если версия элементов технологического стека легаси кода безнадежно отстала? Реализуйте новый модуль в новом приложении и организуйте общение с легаси кодом через адаптеры и дополнительную прослойку в виде брокеров сообщений, например Apache Kafka или RabbitMQ. Может случиться так, что это даже повысит производительность продукта в целом.

Продолжая работу в таком стиле, вы вынесете всю логику из легаси кода в облако модулей, при этом, даже не заикаясь о рефакторинге. Потому что это будет не рефакторинг или реинжиниринг, а рядовая повседневная работа.

Многие понятия в программирование попали из более привычного нам обыденного мира. Полиморфизм, как и классификация с абстрагированием - не изобретение компьютерного мира. Это понятия, на которых работает все в нашем мире вплоть до бытового уровня. Ваша микроволновка разогреет любой объект реализующий интерфейс "Microwavable" - полиморфизм. А классификацией мы сами непроизвольно занимаемся, производя оценку всего того, что видим и слышим. Стоит, я думаю, затянуть в программирование и еще одно понятие – "регулярное омоложение" как в клетках организма. Если старый клетка-модуль слишком стар, то он должен отмереть, а его место занять - новый, содержащий актуальные требования от бизнеса и самые современные стандарты программирования.

Думаю, я изложил свою мысль целиком. В формировании ее не только моя заслуга, так же стоит сказать спасибо моим коллегам. Всем доброго времени суток!

